//      

                                                           
                                                                  
                                                       
                                                                         

const { cyan, magenta, red } = require('chalk')
const fs = require('fs-extra')
const path = require('path')
const request = require('request-promise-native')

// Checks for broken hyperlinks
module.exports = async function (act          ) {
  const target = act.nodes[0].content
  if (target == null || target === '') {
    throw new Error('link without target')
  }
  if (isMailtoLink(target)) {
    act.formatter.skip(`skipping link to ${cyan(target)}`)
    return
  }
  act.formatter.setTitle(`link to ${cyan(target)}`)
  if (isLinkToAnchorInSameFile(target)) {
    await checkLinkToAnchorInSameFile(act.filename, target, act.linkTargets, act.formatter)
  } else if (isLinkToAnchorInOtherFile(target)) {
    await checkLinkToAnchorInOtherFile(act.filename, target, act.linkTargets, act.formatter)
  } else if (isExternalLink(target)) {
    await checkExternalLink(target, act.formatter, act.configuration)
  } else {
    await checkLinkToFilesystem(act.filename, target, act.formatter)
  }
}

async function checkExternalLink (target        , format           , config               ) {
  if (config.get('offline')) {
    format.skip(`skipping link to external website ${target}`)
    return
  }

  try {
    format.setTitle(`link to external website ${cyan(target)}`)
    await request({ url: target, timeout: 4000 })
  } catch (err) {
    if (err.statusCode === 404 || err.error.code === 'ENOTFOUND') {
      format.warning(`link to non-existing external website ${red(target)}`)
    } else if (err.message === 'ESOCKETTIMEDOUT') {
      format.warning(`link to ${magenta(target)} timed out`)
    } else if (err.message.startsWith("Hostname/IP doesn't match certificate's altnames")) {
      format.warning(`link to ${magenta(target)} has error: #{err.message}`)
    } else {
      format.warning(`error while checking link to ${magenta(target)}: ${err}`)
    }
  }
}

async function checkLinkToFilesystem (filename        , target        , format           ) {
  target = path.join(path.dirname(filename), target)
  try {
    const stats = await fs.stat(target)
    if (stats.isDirectory()) {
      format.setTitle(`link to local directory ${cyan(target)}`)
    } else {
      format.setTitle(`link to local file ${cyan(target)}`)
    }
  } catch (err) {
    throw new Error(`link to non-existing local file ${red(target)}`)
  }
}

async function checkLinkToAnchorInSameFile (
  filename        ,
  target        ,
  linkTargets                ,
  format           
) {
  const targetEntry = linkTargets[filename].filter(
    linkTarget => linkTarget.name === target.substr(1)
  )[0]
  if (!targetEntry) {
    throw new Error(`link to non-existing local anchor ${red(target)}`)
  }
  if (targetEntry.type === 'heading') {
    format.setTitle(`link to local heading ${cyan(targetEntry.text)}`)
  } else {
    format.setTitle(`link to #${cyan(targetEntry.name)}`)
  }
}

async function checkLinkToAnchorInOtherFile (
  filename        ,
  target        ,
  linkTargets                ,
  format           
) {
  var [targetFilename, targetAnchor] = target.split('#')
  targetFilename = decodeURI(targetFilename)
  if (linkTargets[targetFilename] == null) {
    throw new Error(
      `link to anchor #${cyan(targetAnchor)} in non-existing file ${red(targetFilename)}`
    )
  }
  const targetEntry = (linkTargets[targetFilename] || []).filter(
    linkTarget => linkTarget.name === targetAnchor
  )[0]
  if (!targetEntry) {
    throw new Error(`link to non-existing anchor #${red(targetAnchor)} in ${cyan(targetFilename)}`)
  }

  if (targetEntry.type === 'heading') {
    format.setTitle(`link to heading ${cyan(targetEntry.text)} in ${cyan(targetFilename)}`)
  } else {
    format.setTitle(`link to ${cyan(targetFilename)}#${cyan(targetAnchor)}`)
  }
}

function isExternalLink (target        )          {
  return target.startsWith('//') || target.startsWith('http://') || target.startsWith('https://')
}

function isLinkToAnchorInOtherFile (target        )          {
  if ((target.match(/#/g) || []).length !== 1) {
    return false
  } else if (/^https?:\/\//.test(target)) {
    return false
  } else {
    return true
  }
}

function isLinkToAnchorInSameFile (target        )          {
  return target.startsWith('#')
}

function isMailtoLink (target        )          {
  return target.startsWith('mailto:')
}
